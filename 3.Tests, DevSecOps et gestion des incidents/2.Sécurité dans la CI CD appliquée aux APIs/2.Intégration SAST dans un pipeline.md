# **10.2 — Intégration SAST dans un pipeline**

Le **SAST** (Static Application Security Testing) est une analyse **du code source** qui permet d’identifier automatiquement des vulnérabilités avant même l’exécution du programme.

Son intégration dans un pipeline CI/CD est l’un des piliers du **Shift Left Security** :

> Le code est analysé à chaque commit, avant d’être déployé.
> On détecte les failles *avant qu’elles n’arrivent en production*.

Ce chapitre explique de manière simple et imagée :

* ce qu’est le SAST,
* ce qu’il détecte,
* comment l’intégrer dans un pipeline,
* son rôle dans la sécurité API,
* les limites à connaître.

---

# **10.2.1 — Qu’est-ce que le SAST ?**

Le SAST est un outil qui lit le **code source** pour y rechercher automatiquement :

* des vulnérabilités connues,
* des patterns dangereux,
* des mauvaises pratiques,
* des erreurs logiques dans la façon d’utiliser des bibliothèques,
* des failles de validation, d’injection, de cryptographie, etc.

### Il n’exécute pas le code → il l’analyse.

On peut comparer cela à un **correcteur orthographique**,
mais pour la sécurité.

---

# **10.2.2 — Que détectent les outils SAST ?**

Les SAST dépendent du langage, mais ils peuvent repérer :

### ✔ Injections (API8)

* SQL Injection
* NoSQL Injection
* Command Injection
* Template Injection

### ✔ Cryptographie faible

* hash MD5, SHA1
* génération d’aléatoire non sécurisé
* clés codées en dur

### ✔ Mauvaise gestion d’erreurs

* stack traces exposées
* messages sensibles

### ✔ Secret leakage

* mots de passe dans le code
* clés d’API dans le dépôt
* tokens hardcodés

### ✔ Patterns dangereux

* concaténation SQL
* absence de validation
* bypass d'autorisation
* pratiques non conformes (OWASP)

---

# **10.2.3 — Exemples de failles que le SAST peut détecter**

### ❌ Exemple 1 — SQL Injection

Code :

```sql
query = "SELECT * FROM users WHERE id = " + userInput;
```

Le SAST déclenche :

```
Warning: Possible SQL Injection (CWE-89)
```

---

### ❌ Exemple 2 — Secret hardcodé

```javascript
const apiKey = "123456-SECRET-PRODUCTION-KEY";
```

SAST :

```
High severity: Hardcoded credential detected (CWE-798)
```

---

### ❌ Exemple 3 — Hashage faible

```python
hashlib.sha1(password).hexdigest()
```

SAST :

```
Use of weak cryptographic function (SHA-1)
```

---

# **10.2.4 — Schéma simple du fonctionnement du SAST dans une CI/CD**

```mermaid
flowchart TD
    A[Développeur push du code] --> B[Pipeline CI démarre]
    B --> C[Étape SAST<br>(analyse du code)]
    C --> D{Failles détectées ?}
    D -->|Oui| E[Pipeline échoue<br>rapport envoyé]
    D -->|Non| F[Build continue<br>vers tests et déploiement]
```

---

# **10.2.5 — Où intégrer le SAST dans le pipeline ?**

Généralement **juste après le checkout du code**, avant :

* build,
* tests unitaires,
* packaging,
* déploiement.

Exemple d’ordre typique :

1. Checkout du code
2. Installation des dépendances
3. SAST
4. Tests unitaires
5. Build application
6. Scan DAST (optionnel)
7. Déploiement

---

# **10.2.6 — Outils SAST populaires**

Selon vos technologies :

### ✔ Outils gratuits / open-source

* Semgrep (très puissant et simple)
* SonarQube Community (limité mais efficace)
* Bandit (Python)
* Brakeman (Rails)
* ESLint + plugins sécurité

### ✔ Outils commerciaux

* Snyk Code
* Checkmarx
* Fortify
* Veracode

---

# **10.2.7 — Exemple d'intégration Semgrep (conceptuel)**

Semgrep fonctionne en lisant votre code et en appliquant des règles.

Pipeline :

```
semgrep scan --config=auto
```

Rapport :

```
Error: Possible SQL Injection
File: api/users.js:45
Rule: javascript.lang.security.detect-sql-injection
Severity: High
```

---

# **10.2.8 — Pourquoi le SAST est crucial pour les APIs ?**

Les API souffrent souvent de :

* validations absentes,
* contrôles d’autorisation incorrects,
* concaténation SQL,
* absence de contrôle de flux,
* mauvaise gestion d’erreur,
* bibliothèques non mises à jour.

Le SAST permet de :

* détecter ces erreurs avant test et déploiement,
* prévenir les failles OWASP API Top 10 (API8, API6, API7…),
* renforcer le Zero Trust,
* améliorer la qualité du code.

---

# **10.2.9 — Que faire lorsque le SAST trouve une faille ?**

### Étape 1 : lire la description

→ comprendre le risque réel

### Étape 2 : analyser le code incriminé

→ vérifier si c’est un faux positif

### Étape 3 : corriger

→ ex : remplacer concaténation SQL par requête paramétrée

### Étape 4 : revalider via SAST

→ s’assurer que la faille est réellement corrigée

### Étape 5 : push et pipeline passe

---

# **10.2.10 — Les limites du SAST**

### ❌ Il ne comprend pas la logique métier

Il ne détecte pas automatiquement les BOLA (API1).

### ❌ Fausse alerte possible

Certains cas sont signalés mais ne sont pas dangereux.

### ❌ Ne détecte pas les vulnérabilités runtime

ex : mauvaise configuration du serveur, CORS, rate limit.

### ❌ Doit être configuré correctement pour être efficace

Mauvais réglage = trop de bruit.

---

# **10.2.11 — Bonnes pratiques pour un SAST efficace**

* ✔ Exécuter le SAST **à chaque commit**
* ✔ Faire échouer le pipeline pour les failles critiques
* ✔ Ajouter des règles custom selon votre architecture API
* ✔ Utiliser Semgrep + SonarQube pour meilleure couverture
* ✔ Documenter les exceptions justifiées
* ✔ Mettre à jour régulièrement les règles de détection

---

# **10.2.12 — Résumé du sous-chapitre**

Le SAST :

* analyse le code source,
* détecte des vulnérabilités avant l’exécution,
* fait partie intégrante du Shift Left Security,
* se met en place dans la CI/CD,
* trouve injections, secrets, cryptographie faible, mauvaises pratiques,
* ne remplace pas les tests manuels ou DAST mais les complète.

Il permet de rendre les APIs **plus sûres dès les premières lignes de code**.
