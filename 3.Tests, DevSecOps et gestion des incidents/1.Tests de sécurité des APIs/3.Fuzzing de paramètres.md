# **9.2 — Tests automatisés (OWASP ZAP, Burp Suite Community)**

Les tests automatisés de sécurité permettent de **scanner une API de manière structurée**, répétable, et beaucoup plus exhaustive qu’un test manuel.
Ils sont essentiels dans une approche **DevSecOps**, car ils permettent :

* d’identifier automatiquement des vulnérabilités connues,
* de tester des comportements anormaux,
* de vérifier l’absence de configurations dangereuses,
* de repérer des failles OWASP API Top 10,
* et d’intégrer ces contrôles dans un pipeline CI/CD.

Dans ce chapitre, nous allons explorer :

* le rôle des outils de test automatisé,
* comment OWASP ZAP et Burp Suite fonctionnent,
* les types de failles qu’ils détectent,
* leurs limites,
* la façon de les utiliser pour les APIs REST.

---

# **9.2.1 — Pourquoi automatiser les tests de sécurité ?**

Les tests manuels sont précieux, mais :

* ils ne couvrent pas tout,
* ils varient selon l’opérateur,
* ils sont difficiles à répéter,
* ils peuvent oublier certaines routes,
* ils ne détectent pas certaines classes de vulnérabilités techniques.

Les tests automatisés :

* sont reproductibles,
* sont plus rapides,
* trouvent des failles simples immédiatement,
* s’intègrent bien dans un pipeline CI/CD,
* détectent les régressions au fil des évolutions.

---

# **9.2.2 — OWASP ZAP et Burp Suite Community : deux outils gratuits majeurs**

## **OWASP ZAP**

* open source, gratuit, maintenu par OWASP
* excellent pour l’automatisation
* idéal pour APIs et applications web
* intégration possible dans CI/CD (Docker, scripts)

## **Burp Suite Community**

* gratuit mais fonctionnalités limitées
* puissant scanner manuel
* détecte déjà de nombreuses failles
* version Pro = scanner automatisé complet

---

# **9.2.3 — Types de vulnérabilités détectées automatiquement**

Ces outils peuvent identifier :

### ✔ Mauvaises configurations (API7)

* CORS trop permissif
* headers de sécurité manquants
* TLS faible
* informations serveur exposées

### ✔ Injections (API8) selon les contextes

* SQL injection
* XSS
* Command injection
* Template injection
* LDAP injection

### ✔ Détection d’erreurs internes

* stack traces exposées
* messages trop verbeux
* chemins internes

### ✔ Endpoints accessibles sans authentification

* routes oubliées
* endpoints admin exposés

### ✔ Vérification de redirections dangereuses

→ open redirects

### ✔ Comportements dangereux

* réponse différente selon existence d’un utilisateur
* disclosures de données internes
* taille de réponse révélatrice d’un accès non autorisé

---

# **9.2.4 — Schéma simple : fonctionnement d’un scanner automatisé**

```mermaid
flowchart TD
    A[Scanner ZAP/Burp] --> B[Découverte d'URL]
    B --> C[Fuzzing des paramètres]
    C --> D[Analyse des réponses]
    D --> E[Détection motifs connus]
    E --> F[Rapport de vulnérabilités]
```

---

# **9.2.5 — Phase 1 : Découverte des endpoints**

Le scanner explore :

* les URL trouvées dans les réponses
* les patterns usuels (`/api/v1/users`, `/auth/login`, etc.)
* les liens exposés dans la documentation OpenAPI
* les endpoints appelés pendant la navigation proxy

Cela permet de cartographier **la surface d'exposition réelle**.

---

# **9.2.6 — Phase 2 : Fuzzing**

Pour détecter les comportements anormaux, le scanner :

* envoie de multiples variantes de paramètres,
* teste des entrées extrêmes,
* joue avec des caractères spéciaux,
* tente des injections connues.

Exemples :

```
' OR 1=1 --
"><script>alert(1)</script>
../../../../etc/passwd
%00%00%00
```

L’objectif est de provoquer :

* une erreur,
* un comportement incohérent,
* une fuite d’information.

---

# **9.2.7 — Phase 3 : Analyse des réponses**

Le scanner analyse automatiquement :

* les codes HTTP
* les erreurs internes
* les variations de taille de réponse
* les redirections
* les patterns de texte sensibles
* les changements entre requêtes valides/invalides

---

# **9.2.8 — Phase 4 : Détection des vulnérabilités**

Exemples de failles détectées :

### BOLA (API1)

→ si l’API renvoie des données différentes selon un ID manipulé.

### Misconfigurations critiques

→ ex : `Access-Control-Allow-Origin: *` avec `Allow-Credentials`.

### Injections

→ si un payload provoque une erreur SQL.

### XSS

→ si un script envoyé se retrouve dans une réponse HTML.

### Leaks d'informations

→ stack trace, version du serveur, chemins internes.

---

# **9.2.9 — Utiliser OWASP ZAP pour tester une API REST**

### Trois modes principaux :

---

## **1) Mode Proxy (manuel)**

ZAP intercepte les requêtes entre le navigateur et l’API.
Permet :

* d’inspecter et modifier dynamiquement les requêtes
* d’appliquer des attaques ciblées
* de comprendre les flux

---

## **2) Mode Spider / Crawler**

Découvre les endpoints automatiquement.

---

## **3) Mode Active Scan**

Lance des attaques automatiques sur les endpoints trouvés.

Exemples :

* injections tentées sur chaque paramètre
* tests systématiques sur chaque route
* validation des headers de sécurité

---

# **9.2.10 — Utiliser Burp Suite Community**

Burp Community n’a pas de scanner automatique (réservé à la version Pro),
mais permet :

* interception et modification des requêtes
* tests manuels avancés
* fuzzing
* inspection des réponses
* détection semi-automatique de patterns dangereux

C’est un excellent outil pour comprendre comment un attaquant interagit avec votre API.

---

# **9.2.11 — Limites des scanners automatisés**

### ❌ Ils ne comprennent pas la logique métier

Exemple :
→ “Un utilisateur ne doit voir que ses propres commandes”
Le scanner n’a pas la notion de "propriétaire".

### ❌ Ils ne détectent pas les défauts d’autorisation profonde (BOLA, BFLA)

Les vulnérabilités complexes nécessitent des tests humains.

### ❌ Ils génèrent parfois des faux positifs

→ notamment sur CORS, XSS, headers, cookies

### ❌ Ils ne remplacent pas les tests manuels

Ils les complètent.

---

# **9.2.12 — Intégration en CI/CD**

OWASP ZAP peut être intégré :

* dans GitHub Actions
* GitLab CI
* Jenkins
* Azure DevOps
* Bitbucket pipelines

L’objectif :

> scanner automatiquement chaque nouvelle version de l’API.

Cela garantit que les failles connues ne réapparaissent pas.

---

# **9.2.13 — Exemple simplifié de pipeline**

```mermaid
flowchart TD
    A[Build API] --> B[Démarrer API de test]
    B --> C[Lancer scan ZAP automatisé]
    C --> D[Analyser rapport]
    D --> E{Failles critiques ?}
    E -->|Oui| F[Échec pipeline]
    E -->|Non| G[Déploiement]
```

---

# **9.2.14 — Résumé du sous-chapitre**

* OWASP ZAP et Burp Suite sont des outils majeurs pour tester la sécurité des APIs.
* Ils détectent automatiquement les injections, misconfigurations, erreurs serveur.
* Ils permettent de fuzzifier les paramètres et observer les comportements.
* Ils ne détectent pas les failles liées à la logique métier (BOLA).
* ZAP peut être automatisé et intégré dans un pipeline CI/CD.
* Burp Community permet des tests manuels très fins.
* Les tests automatisés complètent les tests manuels, mais ne les remplacent pas.

---

Souhaites-tu que l’on continue avec **9.3 — Fuzzing de paramètres** ?


# **9.3 — Fuzzing de paramètres**

Le **fuzzing** (ou *fuzz testing*) consiste à envoyer automatiquement **des valeurs inattendues, extrêmes ou malformées** dans les paramètres d’une API pour observer ses réactions.

C’est l’une des techniques les plus efficaces pour découvrir :

* des crashs,
* des erreurs internes,
* des injections,
* des débordements,
* des comportements imprévus,
* des failles OWASP API Top 10.

Le fuzzing est simple à comprendre, redoutablement efficace, et reflète très bien ce que fait un attaquant dans la réalité.

---

# **9.3.1 — Qu’est-ce que le fuzzing ?**

> Le fuzzing consiste à envoyer automatiquement des valeurs aléatoires, anormales, malformées, trop longues, trop courtes, nulles ou dangereuses dans les paramètres d’une API afin de tester sa robustesse.

### Exemple de paramètres à fuzzifier :

* IDs (URL)
* query params
* corps JSON
* headers
* cookies
* formulaires (si l’API renvoie du HTML)

---

# **9.3.2 — Pourquoi le fuzzing est important pour la sécurité d’une API ?**

Parce que le fuzzing révèle :

### ✔ des erreurs de validation d’entrée (API7 / API3)

Exemples :

* l’API accepte une string au lieu d’un number
* un champ inattendu est traité
* une valeur vide fait planter le service

---

### ✔ des crashs et exceptions du backend

Un simple payload étrange peut générer :

* une stack trace
* une erreur SQL
* une fuite d’information
* un arrêt du serveur

---

### ✔ des injections

Le fuzzing peut déclencher :

* SQLi
* XSS
* NoSQL injection
* template injection
* command injection

---

### ✔ des comportements anormaux

Exemple : envoyer un `userId` très grand :

```
/users/999999999999
```

Peut exposer :

* un défaut de pagination
* un débordement de mémoire
* un comportement logique inattendu

---

# **9.3.3 — Schéma : principe du fuzzing**

```mermaid
flowchart TD
    A[Paramètres à tester] --> B[Génération valeurs inhabituelles]
    B --> C[Envoi massif de requêtes]
    C --> D[Analyse des réponses]
    D --> E[Identific. anomalies<br>erreurs, fuites, crashs]
```

---

# **9.3.4 — Types de valeurs utilisées pour le fuzzing**

Voici des exemples classiques de fuzzers :

---

## **1) Valeurs extrêmes**

* très grands nombres
* nombres négatifs
* nombres flottants improbables
* très longues chaînes
* très longues listes

Exemple :

```
GET /products?limit=99999999
```

---

## **2) Valeurs nulles**

* `null`
* `""` (string vide)
* `[]`
* `{}`

Certaines APIs crashent littéralement sur :

```
{}
```

---

## **3) Caractères spéciaux**

```
'; DROP TABLE users; --
"><script>alert(1)</script>
%00%00%00
../../../etc/passwd
```

Excellent pour tester :

* SQLi
* XSS
* path traversal
* injections diverses

---

## **4) Formats incorrects**

Exemples :

* une date au mauvais format
* un email sans `@`
* un UUID invalide
* un JSON partiellement cassé

---

# **9.3.5 — Outils de fuzzing (simples et avancés)**

### ✔ Dans OWASP ZAP

Module “Fuzzer” intégré :

* sélection d’un paramètre
* sélection de dictionnaires
* génération automatique de requêtes
* observation des différences de réponses

### ✔ Dans Burp Suite (Community : semi-manuel)

Intruder permet le fuzzing, mais limité dans la version gratuite.

### ✔ Fuzzers spécialisés

* ffuf (web fuzzing)
* wfuzz
* boofuzz
* restler (Microsoft) — orienté APIs
* Schemathesis (tests basés sur OpenAPI)

---

# **9.3.6 — Exemple concret : fuzzing d’un paramètre d’ID**

Endpoint :

```
GET /users/{id}
```

Essayons plusieurs valeurs :

| Valeur             | Réponse attendue     | Risque détecté    |
| ------------------ | -------------------- | ----------------- |
| `1`                | 200 (si user existe) | normal            |
| `999999999999`     | 404                  | test robustesse   |
| `-1`               | 400                  | validation entrée |
| `"abc"`            | 400                  | validation type   |
| `<script>`         | 400                  | XSS filtre        |
| `../../etc/passwd` | 400                  | path traversal    |
| `1 OR 1=1`         | 400                  | SQL injection     |

Résultats anormaux révélateurs de failles :

* 500 Internal Server Error
* stack traces
* valeurs internes
* réponse différente selon ID → **BOLA**

---

# **9.3.7 — Exemple : fuzzing d’un JSON**

Endpoint :

```
POST /login
{
  "email": "alice@example.com",
  "password": "123"
}
```

Fuzzing :

```
{}
{"email": ""}
{"password": ""}
{"email": "<script>"}
{"email": {"nested": "value"}}
[]
"string"
1234
true
```

L’API doit toujours répondre :

* **400 Bad Request**
* jamais avec un crash
* jamais avec une stack trace

---

# **9.3.8 — Identifier les anomalies grâce au fuzzing**

Une réponse inhabituelle peut révéler :

### ❌ 200 sur un input invalide

→ validation incorrecte

### ❌ 403 sur un ID imprévu

→ possible fuite : “user existe”

### ❌ 500 Internal Server Error

→ vulnérabilité exploitable

### ❌ temps de réponse différent

→ side-channel / existence d’un objet

### ❌ messages d’erreur trop détaillés

→ fuite d’infos

---

# **9.3.9 — Importance du fuzzing dans une API orientée sécurité**

Le fuzzing permet de tester :

* robustesse globale
* comportement en conditions extrêmes
* absence de débordement
* protection contre injections
* gestion correcte des erreurs
* conformité aux règles de validation
* respect du Zero Trust

Le fuzzing reproduit **exactement ce que ferait un attaquant automatisé.**

---

# **9.3.10 — Résumé du sous-chapitre**

Le fuzzing :

* envoie des valeurs anormales pour tester la robustesse
* identifie des failles invisibles autrement
* détecte injections, erreurs internes, fuites d’informations
* met en évidence les mauvais contrôles d’entrée
* est facile à automatiser avec ZAP ou Burp
* doit faire partie des tests de sécurité systématiques

**C’est l’un des tests les plus efficaces pour sécuriser une API.**